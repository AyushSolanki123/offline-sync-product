type Post {
    id: ID!
    title: String!
    content: String
    post_status: POST_STATUS!
    comments(
        content: ModelStringKeyConditionInput
        filter: ModelCommentFilterInput
        sortDirection: ModelSortDirection
        limit: Int
        nextToken: String
    ): ModelCommentConnection
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    _version: Int!
    _deleted: Boolean
    _lastChangedAt: AWSTimestamp!
}

type Comment {
    id: ID!
    content: String!
    postID: ID!
    post: Post
    createdAt: AWSDateTime!
    updatedAt: AWSDateTime!
    _version: Int!
    _deleted: Boolean
    _lastChangedAt: AWSTimestamp!
}

enum POST_STATUS {
    draft
    published
}

input ModelStringInput {
    ne: String
    eq: String
    le: String
    lt: String
    ge: String
    gt: String
    contains: String
    notContains: String
    between: [String]
    beginsWith: String
    attributeExists: Boolean
    attributeType: ModelAttributeTypes
    size: ModelSizeInput
}

input ModelIntInput {
    ne: Int
    eq: Int
    le: Int
    lt: Int
    ge: Int
    gt: Int
    between: [Int]
    attributeExists: Boolean
    attributeType: ModelAttributeTypes
}

input ModelFloatInput {
    ne: Float
    eq: Float
    le: Float
    lt: Float
    ge: Float
    gt: Float
    between: [Float]
    attributeExists: Boolean
    attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
    ne: Boolean
    eq: Boolean
    attributeExists: Boolean
    attributeType: ModelAttributeTypes
}

input ModelIDInput {
    ne: ID
    eq: ID
    le: ID
    lt: ID
    ge: ID
    gt: ID
    contains: ID
    notContains: ID
    between: [ID]
    beginsWith: ID
    attributeExists: Boolean
    attributeType: ModelAttributeTypes
    size: ModelSizeInput
}

input ModelSubscriptionStringInput {
    ne: String
    eq: String
    le: String
    lt: String
    ge: String
    gt: String
    contains: String
    notContains: String
    between: [String]
    beginsWith: String
    in: [String]
    notIn: [String]
}

input ModelSubscriptionIntInput {
    ne: Int
    eq: Int
    le: Int
    lt: Int
    ge: Int
    gt: Int
    between: [Int]
    in: [Int]
    notIn: [Int]
}

input ModelSubscriptionFloatInput {
    ne: Float
    eq: Float
    le: Float
    lt: Float
    ge: Float
    gt: Float
    between: [Float]
    in: [Float]
    notIn: [Float]
}

input ModelSubscriptionBooleanInput {
    ne: Boolean
    eq: Boolean
}

input ModelSubscriptionIDInput {
    ne: ID
    eq: ID
    le: ID
    lt: ID
    ge: ID
    gt: ID
    contains: ID
    notContains: ID
    between: [ID]
    beginsWith: ID
    in: [ID]
    notIn: [ID]
}

enum ModelAttributeTypes {
    binary
    binarySet
    bool
    list
    map
    number
    numberSet
    string
    stringSet
    _null
}

input ModelSizeInput {
    ne: Int
    eq: Int
    le: Int
    lt: Int
    ge: Int
    gt: Int
    between: [Int]
}

enum ModelSortDirection {
    ASC
    DESC
}

type ModelPostConnection {
    items: [Post]!
    nextToken: String
    startedAt: AWSTimestamp
}

input ModelPOST_STATUSInput {
    eq: POST_STATUS
    ne: POST_STATUS
}

input ModelPostFilterInput {
    id: ModelIDInput
    title: ModelStringInput
    content: ModelStringInput
    image: ModelStringInput
    post_status: ModelPOST_STATUSInput
    and: [ModelPostFilterInput]
    or: [ModelPostFilterInput]
    not: ModelPostFilterInput
}

type Query {
    getPost(id: ID!): Post @function(name: "dataStoreLink-${env}")
    listPosts(
        filter: ModelPostFilterInput
        limit: Int
        nextToken: String
    ): ModelPostConnection @function(name: "dataStoreLink-${env}")
    syncPosts(
        filter: ModelPostFilterInput
        limit: Int
        nextToken: String
        lastSync: AWSTimestamp
    ): ModelPostConnection @function(name: "dataStoreLink-${env}")
    getComment(id: ID!): Comment @function(name: "dataStoreLink-${env}")
    listComments(
        filter: ModelCommentFilterInput
        limit: Int
        nextToken: String
    ): ModelCommentConnection @function(name: "dataStoreLink-${env}")
    syncComments(
        filter: ModelCommentFilterInput
        limit: Int
        nextToken: String
        lastSync: AWSTimestamp
    ): ModelCommentConnection @function(name: "dataStoreLink-${env}")
    commentsByPostIDAndContent(
        postID: ID!
        content: ModelStringKeyConditionInput
        sortDirection: ModelSortDirection
        filter: ModelCommentFilterInput
        limit: Int
        nextToken: String
    ): ModelCommentConnection @function(name: "dataStoreLink-${env}")
}

input ModelPostConditionInput {
    title: ModelStringInput
    content: ModelStringInput
    image: ModelStringInput
    post_status: ModelPOST_STATUSInput
    and: [ModelPostConditionInput]
    or: [ModelPostConditionInput]
    not: ModelPostConditionInput
}

input CreatePostInput {
    id: ID
    title: String!
    content: String
    image: String
    post_status: POST_STATUS!
    _version: Int
}

input UpdatePostInput {
    id: ID!
    title: String
    content: String
    image: String
    post_status: POST_STATUS
    _version: Int
}

input DeletePostInput {
    id: ID!
    _version: Int
}

type Mutation {
    createPost(
        input: CreatePostInput!
        condition: ModelPostConditionInput
    ): Post @function(name: "dataStoreLink-${env}")
    updatePost(
        input: UpdatePostInput!
        condition: ModelPostConditionInput
    ): Post @function(name: "dataStoreLink-${env}")
    deletePost(
        input: DeletePostInput!
        condition: ModelPostConditionInput
    ): Post @function(name: "dataStoreLink-${env}")
    createComment(
        input: CreateCommentInput!
        condition: ModelCommentConditionInput
    ): Comment @function(name: "dataStoreLink-${env}")
    updateComment(
        input: UpdateCommentInput!
        condition: ModelCommentConditionInput
    ): Comment @function(name: "dataStoreLink-${env}")
    deleteComment(
        input: DeleteCommentInput!
        condition: ModelCommentConditionInput
    ): Comment @function(name: "dataStoreLink-${env}")
}

input ModelSubscriptionPostFilterInput {
    id: ModelSubscriptionIDInput
    title: ModelSubscriptionStringInput
    content: ModelSubscriptionStringInput
    image: ModelSubscriptionStringInput
    post_status: ModelSubscriptionStringInput
    and: [ModelSubscriptionPostFilterInput]
    or: [ModelSubscriptionPostFilterInput]
}

type Subscription {
    onCreatePost(filter: ModelSubscriptionPostFilterInput): Post
        @aws_subscribe(mutations: ["createPost"])
    onUpdatePost(filter: ModelSubscriptionPostFilterInput): Post
        @aws_subscribe(mutations: ["updatePost"])
    onDeletePost(filter: ModelSubscriptionPostFilterInput): Post
        @aws_subscribe(mutations: ["deletePost"])
    onCreateComment(filter: ModelSubscriptionCommentFilterInput): Comment
        @aws_subscribe(mutations: ["createComment"])
    onUpdateComment(filter: ModelSubscriptionCommentFilterInput): Comment
        @aws_subscribe(mutations: ["updateComment"])
    onDeleteComment(filter: ModelSubscriptionCommentFilterInput): Comment
        @aws_subscribe(mutations: ["deleteComment"])
}

type ModelCommentConnection {
    items: [Comment]!
    nextToken: String
    startedAt: AWSTimestamp
}

input ModelCommentFilterInput {
    id: ModelIDInput
    content: ModelStringInput
    postID: ModelIDInput
    and: [ModelCommentFilterInput]
    or: [ModelCommentFilterInput]
    not: ModelCommentFilterInput
}

input ModelCommentConditionInput {
    content: ModelStringInput
    postID: ModelIDInput
    and: [ModelCommentConditionInput]
    or: [ModelCommentConditionInput]
    not: ModelCommentConditionInput
}

input CreateCommentInput {
    id: ID
    content: String!
    postID: ID!
    _version: Int
}

input UpdateCommentInput {
    id: ID!
    content: String
    postID: ID
    _version: Int
}

input DeleteCommentInput {
    id: ID!
    _version: Int
}

input ModelSubscriptionCommentFilterInput {
    id: ModelSubscriptionIDInput
    content: ModelSubscriptionStringInput
    postID: ModelSubscriptionIDInput
    and: [ModelSubscriptionCommentFilterInput]
    or: [ModelSubscriptionCommentFilterInput]
}

input ModelStringKeyConditionInput {
    eq: String
    le: String
    lt: String
    ge: String
    gt: String
    between: [String]
    beginsWith: String
}
